/*
 * OANDA v20 REST API
 *
 * The full OANDA v20 REST API Specification. This specification defines how to interact with v20 Accounts, Trades, Orders, Pricing and more.
 *
 * The version of the OpenAPI document: 3.0.25
 * Contact: api@oanda.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`cancel_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelOrderError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::CancelOrder404Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`close_position`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClosePositionError {
    Status400(models::ClosePosition400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::ClosePosition404Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`close_trade`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CloseTradeError {
    Status400(models::CloseTrade400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::CloseTrade404Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configure_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigureAccountError {
    Status400(models::ConfigureAccount400Response),
    Status403(models::ConfigureAccount400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderError {
    Status400(models::CreateOrder400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status403(models::GetInstrumentCandles400Response),
    Status404(models::CreateOrder404Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_changes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountChangesError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    Status416(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_instrument_candles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountInstrumentCandlesError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_instruments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountInstrumentsError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountSummaryError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_base_prices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBasePricesError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_external_user_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExternalUserInfoError {
    Status401(models::GetInstrumentCandles400Response),
    Status403(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_instrument_candles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInstrumentCandlesError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_instrument_price`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInstrumentPriceError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_instrument_price_range`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInstrumentPriceRangeError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_position`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPositionError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_price_range`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPriceRangeError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_prices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricesError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_trade`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTradeError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_range`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionRangeError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    Status416(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transactions_since_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionsSinceIdError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    Status416(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserInfoError {
    Status401(models::GetInstrumentCandles400Response),
    Status403(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`instruments_instrument_order_book_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InstrumentsInstrumentOrderBookGetError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`instruments_instrument_position_book_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InstrumentsInstrumentPositionBookGetError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAccountsError {
    Status401(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_open_positions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOpenPositionsError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_open_trades`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOpenTradesError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOrdersError {
    Status400(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_pending_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPendingOrdersError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_positions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPositionsError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_trades`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTradesError {
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTransactionsError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status403(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    Status416(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceOrderError {
    Status400(models::ReplaceOrder400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::ReplaceOrder404Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_order_client_extensions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetOrderClientExtensionsError {
    Status400(models::SetOrderClientExtensions400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::SetOrderClientExtensions404Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_trade_client_extensions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetTradeClientExtensionsError {
    Status400(models::SetTradeClientExtensions400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::SetTradeClientExtensions404Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_trade_dependent_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetTradeDependentOrdersError {
    Status400(models::SetTradeDependentOrders400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stream_pricing`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StreamPricingError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stream_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StreamTransactionsError {
    Status400(models::GetInstrumentCandles400Response),
    Status401(models::GetInstrumentCandles400Response),
    Status404(models::GetInstrumentCandles400Response),
    Status405(models::GetInstrumentCandles400Response),
    UnknownValue(serde_json::Value),
}


/// Cancel a pending Order in an Account
pub async fn cancel_order(configuration: &configuration::Configuration, authorization: &str, account_id: &str, order_specifier: &str, accept_datetime_format: Option<&str>, client_request_id: Option<&str>) -> Result<models::CancelOrder200Response, Error<CancelOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_order_specifier = order_specifier;
    let p_accept_datetime_format = accept_datetime_format;
    let p_client_request_id = client_request_id;

    let uri_str = format!("{}/accounts/{accountID}/orders/{orderSpecifier}/cancel", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), orderSpecifier=crate::apis::urlencode(p_order_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    if let Some(param_value) = p_client_request_id {
        req_builder = req_builder.header("ClientRequestID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CancelOrder200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CancelOrder200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Closeout the open Position for a specific instrument in an Account.
pub async fn close_position(configuration: &configuration::Configuration, authorization: &str, account_id: &str, instrument: &str, close_position_body: models::ClosePositionRequest, accept_datetime_format: Option<&str>) -> Result<models::ClosePosition200Response, Error<ClosePositionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_instrument = instrument;
    let p_close_position_body = close_position_body;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/positions/{instrument}/close", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    req_builder = req_builder.json(&p_close_position_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClosePosition200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClosePosition200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ClosePositionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Close (partially or fully) a specific open Trade in an Account
pub async fn close_trade(configuration: &configuration::Configuration, authorization: &str, account_id: &str, trade_specifier: &str, close_trade_body: models::CloseTradeRequest, accept_datetime_format: Option<&str>) -> Result<models::CloseTrade200Response, Error<CloseTradeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_trade_specifier = trade_specifier;
    let p_close_trade_body = close_trade_body;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/trades/{tradeSpecifier}/close", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), tradeSpecifier=crate::apis::urlencode(p_trade_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    req_builder = req_builder.json(&p_close_trade_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CloseTrade200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CloseTrade200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CloseTradeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the client-configurable portions of an Account.
pub async fn configure_account(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>, configure_account_body: Option<models::ConfigureAccountRequest>) -> Result<models::ConfigureAccount200Response, Error<ConfigureAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;
    let p_configure_account_body = configure_account_body;

    let uri_str = format!("{}/accounts/{accountID}/configuration", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    req_builder = req_builder.json(&p_configure_account_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigureAccount200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigureAccount200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigureAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create an Order for an Account
pub async fn create_order(configuration: &configuration::Configuration, authorization: &str, account_id: &str, create_order_body: models::CreateOrderRequest, accept_datetime_format: Option<&str>) -> Result<models::CreateOrder201Response, Error<CreateOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_create_order_body = create_order_body;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/orders", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    req_builder = req_builder.json(&p_create_order_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateOrder201Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateOrder201Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the full details for a single Account that a client has access to. Full pending Order, open Trade and open Position representations are provided.
pub async fn get_account(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>) -> Result<models::GetAccount200Response, Error<GetAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccount200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccount200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Endpoint used to poll an Account for its current state and changes since a specified TransactionID.
pub async fn get_account_changes(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>, since_transaction_id: Option<&str>) -> Result<models::GetAccountChanges200Response, Error<GetAccountChangesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;
    let p_since_transaction_id = since_transaction_id;

    let uri_str = format!("{}/accounts/{accountID}/changes", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since_transaction_id {
        req_builder = req_builder.query(&[("sinceTransactionID", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountChanges200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountChanges200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountChangesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch candlestick data for an instrument.
pub async fn get_account_instrument_candles(configuration: &configuration::Configuration, authorization: &str, instrument: &str, accept_datetime_format: Option<&str>, price: Option<&str>, granularity: Option<&str>, count: Option<i32>, from: Option<&str>, to: Option<&str>, smooth: Option<bool>, include_first: Option<bool>, daily_alignment: Option<i32>, alignment_timezone: Option<&str>, weekly_alignment: Option<&str>, units: Option<&str>) -> Result<models::GetInstrumentCandles200Response, Error<GetAccountInstrumentCandlesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_instrument = instrument;
    let p_accept_datetime_format = accept_datetime_format;
    let p_price = price;
    let p_granularity = granularity;
    let p_count = count;
    let p_from = from;
    let p_to = to;
    let p_smooth = smooth;
    let p_include_first = include_first;
    let p_daily_alignment = daily_alignment;
    let p_alignment_timezone = alignment_timezone;
    let p_weekly_alignment = weekly_alignment;
    let p_units = units;

    let uri_str = format!("{}/accounts/{accountID}/instruments/{instrument}/candles", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_granularity {
        req_builder = req_builder.query(&[("granularity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_smooth {
        req_builder = req_builder.query(&[("smooth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_first {
        req_builder = req_builder.query(&[("includeFirst", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_daily_alignment {
        req_builder = req_builder.query(&[("dailyAlignment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_alignment_timezone {
        req_builder = req_builder.query(&[("alignmentTimezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_weekly_alignment {
        req_builder = req_builder.query(&[("weeklyAlignment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_units {
        req_builder = req_builder.query(&[("units", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetInstrumentCandles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetInstrumentCandles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountInstrumentCandlesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of tradeable instruments for the given Account. The list of tradeable instruments is dependent on the regulatory division that the Account is located in, thus should be the same for all Accounts owned by a single user.
pub async fn get_account_instruments(configuration: &configuration::Configuration, authorization: &str, account_id: &str, instruments: Option<Vec<String>>) -> Result<models::GetAccountInstruments200Response, Error<GetAccountInstrumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_instruments = instruments;

    let uri_str = format!("{}/accounts/{accountID}/instruments", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_instruments {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("instruments".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("instruments", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountInstruments200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountInstruments200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountInstrumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a summary for a single Account that a client has access to.
pub async fn get_account_summary(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>) -> Result<models::GetAccountSummary200Response, Error<GetAccountSummaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/summary", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountSummary200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountSummary200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get pricing information for a specified instrument. Accounts are not associated in any way with this endpoint.
pub async fn get_base_prices(configuration: &configuration::Configuration, authorization: &str, accept_datetime_format: Option<&str>, time: Option<&str>) -> Result<models::GetInstrumentPriceRange200Response, Error<GetBasePricesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept_datetime_format = accept_datetime_format;
    let p_time = time;

    let uri_str = format!("{}/pricing", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetInstrumentPriceRange200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetInstrumentPriceRange200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBasePricesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the externally-available user information for the specified user. This endpoint is intended to be used by 3rd parties that have been authorized by a user to view their personal information.
pub async fn get_external_user_info(configuration: &configuration::Configuration, authorization: &str, user_specifier: &str) -> Result<models::GetExternalUserInfo200Response, Error<GetExternalUserInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_user_specifier = user_specifier;

    let uri_str = format!("{}/users/{userSpecifier}/externalInfo", configuration.base_path, userSpecifier=crate::apis::urlencode(p_user_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetExternalUserInfo200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetExternalUserInfo200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExternalUserInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch candlestick data for an instrument.
pub async fn get_instrument_candles(configuration: &configuration::Configuration, authorization: &str, instrument: &str, accept_datetime_format: Option<&str>, price: Option<&str>, granularity: Option<&str>, count: Option<i32>, from: Option<&str>, to: Option<&str>, smooth: Option<bool>, include_first: Option<bool>, daily_alignment: Option<i32>, alignment_timezone: Option<&str>, weekly_alignment: Option<&str>) -> Result<models::GetInstrumentCandles200Response, Error<GetInstrumentCandlesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_instrument = instrument;
    let p_accept_datetime_format = accept_datetime_format;
    let p_price = price;
    let p_granularity = granularity;
    let p_count = count;
    let p_from = from;
    let p_to = to;
    let p_smooth = smooth;
    let p_include_first = include_first;
    let p_daily_alignment = daily_alignment;
    let p_alignment_timezone = alignment_timezone;
    let p_weekly_alignment = weekly_alignment;

    let uri_str = format!("{}/instruments/{instrument}/candles", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_granularity {
        req_builder = req_builder.query(&[("granularity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_smooth {
        req_builder = req_builder.query(&[("smooth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_first {
        req_builder = req_builder.query(&[("includeFirst", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_daily_alignment {
        req_builder = req_builder.query(&[("dailyAlignment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_alignment_timezone {
        req_builder = req_builder.query(&[("alignmentTimezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_weekly_alignment {
        req_builder = req_builder.query(&[("weeklyAlignment", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetInstrumentCandles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetInstrumentCandles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInstrumentCandlesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a price for an instrument. Accounts are not associated in any way with this endpoint.
pub async fn get_instrument_price(configuration: &configuration::Configuration, authorization: &str, instrument: &str, accept_datetime_format: Option<&str>, time: Option<&str>) -> Result<models::GetInstrumentPrice200Response, Error<GetInstrumentPriceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_instrument = instrument;
    let p_accept_datetime_format = accept_datetime_format;
    let p_time = time;

    let uri_str = format!("{}/instruments/{instrument}/price", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetInstrumentPrice200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetInstrumentPrice200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInstrumentPriceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a range of prices for an instrument. Accounts are not associated in any way with this endpoint.
pub async fn get_instrument_price_range(configuration: &configuration::Configuration, authorization: &str, instrument: &str, from: &str, accept_datetime_format: Option<&str>, to: Option<&str>) -> Result<models::GetInstrumentPriceRange200Response, Error<GetInstrumentPriceRangeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_instrument = instrument;
    let p_from = from;
    let p_accept_datetime_format = accept_datetime_format;
    let p_to = to;

    let uri_str = format!("{}/instruments/{instrument}/price/range", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from", &p_from.to_string())]);
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetInstrumentPriceRange200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetInstrumentPriceRange200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInstrumentPriceRangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get details for a single Order in an Account
pub async fn get_order(configuration: &configuration::Configuration, authorization: &str, account_id: &str, order_specifier: &str, accept_datetime_format: Option<&str>) -> Result<models::GetOrder200Response, Error<GetOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_order_specifier = order_specifier;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/orders/{orderSpecifier}", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), orderSpecifier=crate::apis::urlencode(p_order_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetOrder200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetOrder200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of a single Instrument's Position in an Account. The Position may by open or not.
pub async fn get_position(configuration: &configuration::Configuration, authorization: &str, account_id: &str, instrument: &str) -> Result<models::GetPosition200Response, Error<GetPositionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_instrument = instrument;

    let uri_str = format!("{}/accounts/{accountID}/positions/{instrument}", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPosition200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPosition200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPositionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get pricing information for a specified range of prices. Accounts are not associated in any way with this endpoint.
pub async fn get_price_range(configuration: &configuration::Configuration, authorization: &str, instrument: &str, from: &str, accept_datetime_format: Option<&str>, to: Option<&str>) -> Result<models::GetInstrumentPriceRange200Response, Error<GetPriceRangeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_instrument = instrument;
    let p_from = from;
    let p_accept_datetime_format = accept_datetime_format;
    let p_to = to;

    let uri_str = format!("{}/pricing/range", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from", &p_from.to_string())]);
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetInstrumentPriceRange200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetInstrumentPriceRange200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPriceRangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get pricing information for a specified list of Instruments within an Account.
pub async fn get_prices(configuration: &configuration::Configuration, authorization: &str, account_id: &str, instruments: Vec<String>, accept_datetime_format: Option<&str>, since: Option<&str>, include_units_available: Option<bool>, include_home_conversions: Option<bool>) -> Result<models::GetPrices200Response, Error<GetPricesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_instruments = instruments;
    let p_accept_datetime_format = accept_datetime_format;
    let p_since = since;
    let p_include_units_available = include_units_available;
    let p_include_home_conversions = include_home_conversions;

    let uri_str = format!("{}/accounts/{accountID}/pricing", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_instruments.into_iter().map(|p| ("instruments".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("instruments", &p_instruments.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_units_available {
        req_builder = req_builder.query(&[("includeUnitsAvailable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_home_conversions {
        req_builder = req_builder.query(&[("includeHomeConversions", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPrices200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPrices200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPricesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of a specific Trade in an Account
pub async fn get_trade(configuration: &configuration::Configuration, authorization: &str, account_id: &str, trade_specifier: &str, accept_datetime_format: Option<&str>) -> Result<models::GetTrade200Response, Error<GetTradeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_trade_specifier = trade_specifier;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/trades/{tradeSpecifier}", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), tradeSpecifier=crate::apis::urlencode(p_trade_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTrade200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTrade200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTradeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of a single Account Transaction.
pub async fn get_transaction(configuration: &configuration::Configuration, authorization: &str, account_id: &str, transaction_id: &str, accept_datetime_format: Option<&str>) -> Result<models::GetTransaction200Response, Error<GetTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_transaction_id = transaction_id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/transactions/{transactionID}", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), transactionID=crate::apis::urlencode(p_transaction_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTransaction200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTransaction200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a range of Transactions for an Account based on the Transaction IDs.
pub async fn get_transaction_range(configuration: &configuration::Configuration, authorization: &str, account_id: &str, from: &str, to: &str, accept_datetime_format: Option<&str>, r#type: Option<Vec<String>>) -> Result<models::GetTransactionRange200Response, Error<GetTransactionRangeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_from = from;
    let p_to = to;
    let p_accept_datetime_format = accept_datetime_format;
    let p_type = r#type;

    let uri_str = format!("{}/accounts/{accountID}/transactions/idrange", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from", &p_from.to_string())]);
    req_builder = req_builder.query(&[("to", &p_to.to_string())]);
    if let Some(ref param_value) = p_type {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("type".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("type", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTransactionRange200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTransactionRange200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransactionRangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a range of Transactions for an Account starting at (but not including) a provided Transaction ID.
pub async fn get_transactions_since_id(configuration: &configuration::Configuration, authorization: &str, account_id: &str, id: &str, accept_datetime_format: Option<&str>) -> Result<models::GetTransactionRange200Response, Error<GetTransactionsSinceIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_id = id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/transactions/sinceid", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTransactionRange200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTransactionRange200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransactionsSinceIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the user information for the specified user. This endpoint is intended to be used by the user themself to obtain their own information.
pub async fn get_user_info(configuration: &configuration::Configuration, authorization: &str, user_specifier: &str) -> Result<models::GetUserInfo200Response, Error<GetUserInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_user_specifier = user_specifier;

    let uri_str = format!("{}/users/{userSpecifier}", configuration.base_path, userSpecifier=crate::apis::urlencode(p_user_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUserInfo200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUserInfo200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch an order book for an instrument.
pub async fn instruments_instrument_order_book_get(configuration: &configuration::Configuration, authorization: &str, instrument: &str, accept_datetime_format: Option<&str>, time: Option<&str>) -> Result<models::InstrumentsInstrumentOrderBookGet200Response, Error<InstrumentsInstrumentOrderBookGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_instrument = instrument;
    let p_accept_datetime_format = accept_datetime_format;
    let p_time = time;

    let uri_str = format!("{}/instruments/{instrument}/orderBook", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstrumentsInstrumentOrderBookGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstrumentsInstrumentOrderBookGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InstrumentsInstrumentOrderBookGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a position book for an instrument.
pub async fn instruments_instrument_position_book_get(configuration: &configuration::Configuration, authorization: &str, instrument: &str, accept_datetime_format: Option<&str>, time: Option<&str>) -> Result<models::InstrumentsInstrumentPositionBookGet200Response, Error<InstrumentsInstrumentPositionBookGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_instrument = instrument;
    let p_accept_datetime_format = accept_datetime_format;
    let p_time = time;

    let uri_str = format!("{}/instruments/{instrument}/positionBook", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstrumentsInstrumentPositionBookGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstrumentsInstrumentPositionBookGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InstrumentsInstrumentPositionBookGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all Accounts authorized for the provided token.
pub async fn list_accounts(configuration: &configuration::Configuration, authorization: &str) -> Result<models::ListAccounts200Response, Error<ListAccountsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;

    let uri_str = format!("{}/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListAccounts200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListAccounts200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAccountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all open Positions for an Account. An open Position is a Position in an Account that currently has a Trade opened for it.
pub async fn list_open_positions(configuration: &configuration::Configuration, authorization: &str, account_id: &str) -> Result<models::ListOpenPositions200Response, Error<ListOpenPositionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;

    let uri_str = format!("{}/accounts/{accountID}/openPositions", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListOpenPositions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListOpenPositions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListOpenPositionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of open Trades for an Account
pub async fn list_open_trades(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>) -> Result<models::ListOpenTrades200Response, Error<ListOpenTradesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/openTrades", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListOpenTrades200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListOpenTrades200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListOpenTradesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of Orders for an Account
pub async fn list_orders(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>, ids: Option<Vec<String>>, state: Option<&str>, instrument: Option<&str>, count: Option<i32>, before_id: Option<&str>) -> Result<models::ListOrders200Response, Error<ListOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;
    let p_ids = ids;
    let p_state = state;
    let p_instrument = instrument;
    let p_count = count;
    let p_before_id = before_id;

    let uri_str = format!("{}/accounts/{accountID}/orders", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ids {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_instrument {
        req_builder = req_builder.query(&[("instrument", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before_id {
        req_builder = req_builder.query(&[("beforeID", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListOrders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListOrders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all pending Orders in an Account
pub async fn list_pending_orders(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>) -> Result<models::ListPendingOrders200Response, Error<ListPendingOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/pendingOrders", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListPendingOrders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListPendingOrders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPendingOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all Positions for an Account. The Positions returned are for every instrument that has had a position during the lifetime of an the Account.
pub async fn list_positions(configuration: &configuration::Configuration, authorization: &str, account_id: &str) -> Result<models::ListPositions200Response, Error<ListPositionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;

    let uri_str = format!("{}/accounts/{accountID}/positions", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListPositions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListPositions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPositionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of Trades for an Account
pub async fn list_trades(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>, ids: Option<Vec<String>>, state: Option<&str>, instrument: Option<&str>, count: Option<i32>, before_id: Option<&str>) -> Result<models::ListTrades200Response, Error<ListTradesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;
    let p_ids = ids;
    let p_state = state;
    let p_instrument = instrument;
    let p_count = count;
    let p_before_id = before_id;

    let uri_str = format!("{}/accounts/{accountID}/trades", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ids {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_instrument {
        req_builder = req_builder.query(&[("instrument", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before_id {
        req_builder = req_builder.query(&[("beforeID", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListTrades200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListTrades200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTradesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of Transactions pages that satisfy a time-based Transaction query.
pub async fn list_transactions(configuration: &configuration::Configuration, authorization: &str, account_id: &str, accept_datetime_format: Option<&str>, from: Option<&str>, to: Option<&str>, page_size: Option<i32>, r#type: Option<Vec<String>>) -> Result<models::ListTransactions200Response, Error<ListTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;
    let p_from = from;
    let p_to = to;
    let p_page_size = page_size;
    let p_type = r#type;

    let uri_str = format!("{}/accounts/{accountID}/transactions", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("type".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("type", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListTransactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListTransactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replace an Order in an Account by simultaneously cancelling it and creating a replacement Order
pub async fn replace_order(configuration: &configuration::Configuration, authorization: &str, account_id: &str, order_specifier: &str, replace_order_body: models::CreateOrderRequest, accept_datetime_format: Option<&str>, client_request_id: Option<&str>) -> Result<models::ReplaceOrder201Response, Error<ReplaceOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_order_specifier = order_specifier;
    let p_replace_order_body = replace_order_body;
    let p_accept_datetime_format = accept_datetime_format;
    let p_client_request_id = client_request_id;

    let uri_str = format!("{}/accounts/{accountID}/orders/{orderSpecifier}", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), orderSpecifier=crate::apis::urlencode(p_order_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    if let Some(param_value) = p_client_request_id {
        req_builder = req_builder.header("ClientRequestID", param_value.to_string());
    }
    req_builder = req_builder.json(&p_replace_order_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReplaceOrder201Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReplaceOrder201Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReplaceOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the Client Extensions for an Order in an Account. Do not set, modify, or delete clientExtensions if your account is associated with MT4.
pub async fn set_order_client_extensions(configuration: &configuration::Configuration, authorization: &str, account_id: &str, order_specifier: &str, set_order_client_extensions_body: models::SetOrderClientExtensionsRequest, accept_datetime_format: Option<&str>) -> Result<models::SetOrderClientExtensions200Response, Error<SetOrderClientExtensionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_order_specifier = order_specifier;
    let p_set_order_client_extensions_body = set_order_client_extensions_body;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/orders/{orderSpecifier}/clientExtensions", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), orderSpecifier=crate::apis::urlencode(p_order_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    req_builder = req_builder.json(&p_set_order_client_extensions_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetOrderClientExtensions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetOrderClientExtensions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetOrderClientExtensionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the Client Extensions for a Trade. Do not add, update, or delete the Client Extensions if your account is associated with MT4.
pub async fn set_trade_client_extensions(configuration: &configuration::Configuration, authorization: &str, account_id: &str, trade_specifier: &str, set_trade_client_extensions_body: models::SetTradeClientExtensionsRequest, accept_datetime_format: Option<&str>) -> Result<models::SetTradeClientExtensions200Response, Error<SetTradeClientExtensionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_trade_specifier = trade_specifier;
    let p_set_trade_client_extensions_body = set_trade_client_extensions_body;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/trades/{tradeSpecifier}/clientExtensions", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), tradeSpecifier=crate::apis::urlencode(p_trade_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    req_builder = req_builder.json(&p_set_trade_client_extensions_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetTradeClientExtensions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetTradeClientExtensions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetTradeClientExtensionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create, replace and cancel a Trade's dependent Orders (Take Profit, Stop Loss and Trailing Stop Loss) through the Trade itself
pub async fn set_trade_dependent_orders(configuration: &configuration::Configuration, authorization: &str, account_id: &str, trade_specifier: &str, set_trade_dependent_orders_body: models::SetTradeDependentOrdersRequest, accept_datetime_format: Option<&str>) -> Result<models::SetTradeDependentOrders200Response, Error<SetTradeDependentOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_trade_specifier = trade_specifier;
    let p_set_trade_dependent_orders_body = set_trade_dependent_orders_body;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountID}/trades/{tradeSpecifier}/orders", configuration.base_path, accountID=crate::apis::urlencode(p_account_id), tradeSpecifier=crate::apis::urlencode(p_trade_specifier));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    req_builder = req_builder.json(&p_set_trade_dependent_orders_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetTradeDependentOrders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetTradeDependentOrders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetTradeDependentOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a stream of Account Prices starting from when the request is made. This pricing stream does not include every single price created for the Account, but instead will provide at most 4 prices per second (every 250 milliseconds) for each instrument being requested. If more than one price is created for an instrument during the 250 millisecond window, only the price in effect at the end of the window is sent. This means that during periods of rapid price movement, subscribers to this stream will not be sent every price. Pricing windows for different connections to the price stream are not all aligned in the same way (i.e. they are not all aligned to the top of the second). This means that during periods of rapid price movement, different subscribers may observe different prices depending on their alignment.
pub async fn stream_pricing(configuration: &configuration::Configuration, authorization: &str, account_id: &str, instruments: Vec<String>, accept_datetime_format: Option<&str>, snapshot: Option<bool>) -> Result<models::StreamPricing200Response, Error<StreamPricingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_instruments = instruments;
    let p_accept_datetime_format = accept_datetime_format;
    let p_snapshot = snapshot;

    let uri_str = format!("{}/accounts/{accountID}/pricing/stream", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_instruments.into_iter().map(|p| ("instruments".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("instruments", &p_instruments.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_snapshot {
        req_builder = req_builder.query(&[("snapshot", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StreamPricing200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StreamPricing200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StreamPricingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a stream of Transactions for an Account starting from when the request is made.
pub async fn stream_transactions(configuration: &configuration::Configuration, authorization: &str, account_id: &str) -> Result<models::StreamTransactions200Response, Error<StreamTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;

    let uri_str = format!("{}/accounts/{accountID}/transactions/stream", configuration.base_path, accountID=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StreamTransactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StreamTransactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StreamTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

